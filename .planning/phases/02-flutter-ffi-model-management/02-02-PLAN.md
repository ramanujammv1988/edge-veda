---
phase: 02-flutter-ffi-model-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - flutter/lib/src/types.dart
  - flutter/lib/src/model_manager.dart
autonomous: true

must_haves:
  truths:
    - "Model downloads emit progress 0-100% during download"
    - "Checksum mismatch throws ModelValidationException"
    - "Re-download is skipped if valid model exists locally"
    - "Download interruption leaves no corrupt files"
  artifacts:
    - path: "flutter/lib/src/types.dart"
      provides: "Exception hierarchy with ModelValidationException"
      exports: ["ModelValidationException", "DownloadException", "ChecksumException"]
    - path: "flutter/lib/src/model_manager.dart"
      provides: "Atomic download with temp file pattern"
      contains: ".tmp"
  key_links:
    - from: "flutter/lib/src/model_manager.dart"
      to: "types.dart"
      via: "exception imports"
      pattern: "import.*types.dart"
    - from: "flutter/lib/src/model_manager.dart"
      to: "crypto package"
      via: "sha256 checksum"
      pattern: "sha256.bind"
---

<objective>
Harden model download flow with atomic temp file pattern and ensure typed exception hierarchy covers all Phase 2 error cases.

Purpose: Downloads must be crash-safe (Pitfall 12), and errors must be typed not generic (R4.1, R4.2).
Output: Robust model manager and complete exception types.
</objective>

<execution_context>
@/Users/ram/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ram/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-flutter-ffi-model-management/02-RESEARCH.md

# Existing files to update
@flutter/lib/src/types.dart
@flutter/lib/src/model_manager.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ModelValidationException and error code mapping</name>
  <files>flutter/lib/src/types.dart</files>
  <action>
Update types.dart to add missing exception types and error code mapping:

1. **Add ModelValidationException** (alias for ChecksumException or new class):
```dart
/// Thrown when model file fails validation (checksum mismatch, corrupted file)
class ModelValidationException extends EdgeVedaException {
  const ModelValidationException(super.message, {super.details, super.originalError});
}
```
Note: The existing ChecksumException can remain - ModelValidationException is for broader validation failures.

2. **Add NativeErrorCode enum** matching edge_veda.h ev_error_t:
```dart
enum NativeErrorCode {
  success(0),
  invalidParam(-1),
  outOfMemory(-2),
  modelLoadFailed(-3),
  backendInitFailed(-4),
  inferenceFailed(-5),
  contextInvalid(-6),
  streamEnded(-7),
  notImplemented(-8),
  memoryLimitExceeded(-9),
  unsupportedBackend(-10),
  unknown(-999);

  final int code;
  const NativeErrorCode(this.code);

  static NativeErrorCode fromCode(int code) {
    return NativeErrorCode.values.firstWhere(
      (e) => e.code == code,
      orElse: () => NativeErrorCode.unknown,
    );
  }

  /// Convert to appropriate EdgeVedaException
  EdgeVedaException toException([String? details]) {
    switch (this) {
      case NativeErrorCode.outOfMemory:
      case NativeErrorCode.memoryLimitExceeded:
        return MemoryException('Out of memory', details: details);
      case NativeErrorCode.modelLoadFailed:
        return ModelLoadException('Failed to load model', details: details);
      // ... map all codes
    }
  }
}
```

3. **Ensure all R4.1 typed exceptions exist**:
   - InitializationException (exists)
   - ModelLoadException (exists)
   - GenerationException (exists)
   - DownloadException (exists)
   - ChecksumException (exists)
   - ModelValidationException (NEW)
   - MemoryException (exists)
   - ConfigurationException (exists)

4. **Add MemoryPressureEvent** type for callback propagation:
```dart
class MemoryPressureEvent {
  final int currentBytes;
  final int limitBytes;
  double get usagePercent => limitBytes > 0 ? currentBytes / limitBytes : 0;
  const MemoryPressureEvent(this.currentBytes, this.limitBytes);
}
```
  </action>
  <verify>
Run: `cd flutter && dart analyze lib/src/types.dart`
Expected: No errors. All exception types defined.
  </verify>
  <done>
types.dart exports all exception types needed for Phase 2 (ModelValidationException, MemoryPressureEvent, NativeErrorCode).
  </done>
</task>

<task type="auto">
  <name>Task 2: Harden model download with atomic temp file pattern</name>
  <files>flutter/lib/src/model_manager.dart</files>
  <action>
Update model_manager.dart to implement crash-safe download:

1. **Fix the streaming request issue** - Current code does `await request.send()` but `request` is an http.Request. Should be:
```dart
final client = http.Client();
try {
  final response = await client.send(request);
  // ... use response.stream
} finally {
  client.close();
}
```

2. **Atomic temp file pattern** (already partially there, verify correct):
   - Download to `$modelPath.tmp`
   - Verify checksum BEFORE rename
   - Use `await tempFile.rename(modelPath)` for atomic move
   - Delete temp file in catch block if download fails

3. **Progress edge cases**:
   - Handle `response.contentLength == null` (server doesn't send content-length): use model.sizeBytes as fallback
   - Handle progress going backwards (shouldn't happen, but guard against it)
   - Emit final 100% progress after successful rename

4. **Add download cancellation support**:
```dart
CancelToken? _currentDownloadToken;

Future<String> downloadModel(ModelInfo model, {CancelToken? cancelToken}) async {
  _currentDownloadToken = cancelToken;
  // Check cancelToken.isCancelled in the await for loop
}

void cancelDownload() {
  _currentDownloadToken?.cancel();
}
```
Note: CancelToken is a simple class with `bool isCancelled` and `void cancel()`.

5. **Use ModelValidationException** for checksum failures:
```dart
if (!isValid) {
  await tempFile.delete();
  throw ModelValidationException(
    'SHA256 checksum mismatch',
    details: 'Expected: ${model.checksum}, file may be corrupted',
  );
}
```

6. **Add retry logic for transient network errors** (optional enhancement):
   - Retry up to 3 times on SocketException
   - Exponential backoff (1s, 2s, 4s)

7. **Ensure applicationSupportDirectory usage** (already correct, verify):
   - Use `getApplicationSupportDirectory()` not `getApplicationDocumentsDirectory()`
   - This prevents iCloud backup issues (Pitfall 4)
  </action>
  <verify>
Run: `cd flutter && dart analyze lib/src/model_manager.dart`
Expected: No errors. Download flow uses temp file pattern.
  </verify>
  <done>
model_manager.dart downloads to .tmp file, verifies checksum, then atomic renames. Checksum mismatch throws ModelValidationException.
  </done>
</task>

</tasks>

<verification>
1. Run: `cd flutter && dart analyze` - zero errors
2. Grep for temp file pattern: `grep -n "\.tmp" flutter/lib/src/model_manager.dart` - should find temp file usage
3. Grep for ModelValidationException: `grep -n "ModelValidationException" flutter/lib/src/model_manager.dart` - should find throw statement
</verification>

<success_criteria>
- types.dart exports ModelValidationException, MemoryPressureEvent, NativeErrorCode
- model_manager.dart uses atomic temp file pattern
- Checksum mismatch throws ModelValidationException (not generic Exception)
- Download progress emits 0-100% with totalBytes from Content-Length or fallback
</success_criteria>

<output>
After completion, create `.planning/phases/02-flutter-ffi-model-management/02-02-SUMMARY.md`
</output>
