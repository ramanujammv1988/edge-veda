---
phase: 02-flutter-ffi-model-management
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - flutter/lib/src/edge_veda_impl.dart
autonomous: true

must_haves:
  truths:
    - "All inference calls run in background isolate (UI never blocks)"
    - "DynamicLibrary is re-loaded in each isolate (no pointer transfer)"
    - "Native memory is freed in all code paths (success, error, cancel)"
  artifacts:
    - path: "flutter/lib/src/edge_veda_impl.dart"
      provides: "Non-blocking SDK implementation using Isolate.run()"
      contains: "Isolate.run"
      min_lines: 150
  key_links:
    - from: "flutter/lib/src/edge_veda_impl.dart"
      to: "flutter/lib/src/ffi/bindings.dart"
      via: "FFI bindings import"
      pattern: "import.*bindings.dart"
    - from: "flutter/lib/src/edge_veda_impl.dart"
      to: "Isolate.run"
      via: "background execution"
      pattern: "Isolate\\.run"
---

<objective>
Rewrite EdgeVeda implementation to use Isolate.run() for all FFI calls, preventing UI thread blocking.

Purpose: FFI calls are synchronous and will freeze the UI (Pitfall 3 - Critical). Using Isolate.run() offloads blocking work to background isolates.
Output: Non-blocking SDK that keeps UI responsive during inference.
</objective>

<execution_context>
@/Users/ram/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ram/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-flutter-ffi-model-management/02-RESEARCH.md

# Dependencies from earlier plans
@flutter/lib/src/ffi/bindings.dart
@flutter/lib/src/ffi/native_memory.dart
@flutter/lib/src/types.dart

# File to rewrite
@flutter/lib/src/edge_veda_impl.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite EdgeVeda class with Isolate.run() pattern</name>
  <files>flutter/lib/src/edge_veda_impl.dart</files>
  <action>
Completely rewrite edge_veda_impl.dart to use background isolates for all FFI calls:

1. **Remove main isolate context storage** - Cannot store Pointer across isolates:
```dart
class EdgeVeda {
  EdgeVedaConfig? _config;
  bool _isInitialized = false;
  // NO: ffi.Pointer<EdgeVedaContext>? _context; - Pointers can't transfer between isolates
}
```

2. **init() - Validate in background isolate, don't keep context**:
```dart
Future<void> init(EdgeVedaConfig config) async {
  if (_isInitialized) {
    throw InitializationException('Already initialized. Call dispose() first.');
  }

  _config = config;

  // Validate model file exists (can do on main isolate - just File.exists)
  final file = File(config.modelPath);
  if (!await file.exists()) {
    throw ModelLoadException('Model file not found: ${config.modelPath}');
  }

  // Test initialization in background isolate to verify model loads
  // Pass only primitive data - no Pointers!
  final modelPath = config.modelPath;
  final numThreads = config.numThreads;
  final contextSize = config.contextLength;
  final useGpu = config.useGpu;

  await Isolate.run<void>(() {
    final bindings = EdgeVedaNativeBindings.instance; // Re-load in isolate
    final configScope = NativeConfigScope.create(
      modelPath: modelPath,
      numThreads: numThreads,
      contextSize: contextSize,
      useGpu: useGpu,
    );
    final errorPtr = calloc<Int32>();

    try {
      final ctx = bindings.evInit(configScope.ptr, errorPtr);
      if (ctx == nullptr) {
        final errorCode = NativeErrorCode.fromCode(errorPtr.value);
        throw errorCode.toException('Init validation failed');
      }
      // Immediately free - we just tested it works
      bindings.evFree(ctx);
    } finally {
      configScope.free();
      calloc.free(errorPtr);
    }
  });

  _isInitialized = true;
}
```

3. **generate() - Full operation in background isolate**:
```dart
Future<GenerateResponse> generate(String prompt, {GenerateOptions? options}) async {
  _ensureInitialized();
  options ??= const GenerateOptions();

  // Capture all config values as primitives
  final modelPath = _config!.modelPath;
  final numThreads = _config!.numThreads;
  final contextSize = _config!.contextLength;
  final useGpu = _config!.useGpu;
  final maxTokens = options.maxTokens;
  final temperature = options.temperature;
  final topP = options.topP;
  final topK = options.topK;
  final repeatPenalty = options.repeatPenalty;

  final startTime = DateTime.now();

  // Run entire generate in background isolate
  final generatedText = await Isolate.run<String>(() {
    final bindings = EdgeVedaNativeBindings.instance;

    // Create config and init context
    final configScope = NativeConfigScope.create(
      modelPath: modelPath,
      numThreads: numThreads,
      contextSize: contextSize,
      useGpu: useGpu,
    );
    final errorPtr = calloc<Int32>();

    ffi.Pointer<ev_context_impl>? ctx;
    try {
      ctx = bindings.evInit(configScope.ptr, errorPtr);
      if (ctx == nullptr) {
        throw NativeErrorCode.fromCode(errorPtr.value).toException();
      }

      // Create generation params
      final paramsScope = NativeParamsScope.create(
        maxTokens: maxTokens,
        temperature: temperature,
        topP: topP,
        topK: topK,
        repeatPenalty: repeatPenalty,
      );

      // Allocate output pointer
      final outputPtr = calloc<ffi.Pointer<Utf8>>();

      try {
        final promptPtr = prompt.toNativeUtf8();
        try {
          final result = bindings.evGenerate(ctx, promptPtr, paramsScope.ptr, outputPtr);
          if (result != 0) {
            throw NativeErrorCode.fromCode(result).toException();
          }

          // Read output and free C++-allocated string
          final output = outputPtr.value.toDartString();
          bindings.evFreeString(outputPtr.value);
          return output;
        } finally {
          calloc.free(promptPtr);
        }
      } finally {
        paramsScope.free();
        calloc.free(outputPtr);
      }
    } finally {
      if (ctx != null && ctx != nullptr) {
        bindings.evFree(ctx);
      }
      configScope.free();
      calloc.free(errorPtr);
    }
  });

  final latencyMs = DateTime.now().difference(startTime).inMilliseconds;

  return GenerateResponse(
    text: generatedText,
    promptTokens: 0, // TODO: Get from native if needed
    completionTokens: 0, // TODO: Get from native if needed
    latencyMs: latencyMs,
  );
}
```

4. **Remove streaming for v1** - Streaming requires long-lived worker isolate pattern, defer to v2:
```dart
// TODO(v2): Implement streaming with SendPort/ReceivePort worker isolate
// Stream<TokenChunk> generateStream(...) { ... }
```

5. **dispose() - Just clear config**:
```dart
Future<void> dispose() async {
  _isInitialized = false;
  _config = null;
}
```

6. **Add proper imports**:
```dart
import 'dart:async';
import 'dart:ffi' as ffi;
import 'dart:io';
import 'dart:isolate';
import 'package:ffi/ffi.dart';

import 'ffi/bindings.dart';
import 'ffi/native_memory.dart';
import 'types.dart';
```

7. **Helper method for ensuring initialization**:
```dart
void _ensureInitialized() {
  if (!_isInitialized || _config == null) {
    throw InitializationException('EdgeVeda not initialized. Call init() first.');
  }
}
```

KEY INSIGHT: Each Isolate.run() call:
1. Re-loads DynamicLibrary (via EdgeVedaNativeBindings.instance)
2. Creates a fresh context (ev_init)
3. Performs operation
4. Frees context (ev_free)
5. Returns only primitive data (String, int, etc.)

This is less efficient than keeping context alive but is the CORRECT pattern for v1.
For v2, implement a long-lived worker isolate with SendPort/ReceivePort.
  </action>
  <verify>
Run: `cd flutter && dart analyze lib/src/edge_veda_impl.dart`
Expected: No errors. No direct FFI calls outside Isolate.run().
Grep: `grep -n "Isolate.run" flutter/lib/src/edge_veda_impl.dart` should find at least 2 occurrences (init, generate).
  </verify>
  <done>
edge_veda_impl.dart uses Isolate.run() for init() and generate(). No Pointer storage on main isolate. UI never blocks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add configuration validation and error handling</name>
  <files>flutter/lib/src/edge_veda_impl.dart</files>
  <action>
Enhance error handling and add proper validation:

1. **Configuration validation** (run on main isolate - no FFI):
```dart
void _validateConfig(EdgeVedaConfig config) {
  if (config.modelPath.isEmpty) {
    throw ConfigurationException('Model path cannot be empty');
  }
  if (config.numThreads < 1 || config.numThreads > 32) {
    throw ConfigurationException(
      'numThreads must be between 1 and 32',
      details: 'Got: ${config.numThreads}',
    );
  }
  if (config.contextLength < 128 || config.contextLength > 32768) {
    throw ConfigurationException(
      'contextLength must be between 128 and 32768',
      details: 'Got: ${config.contextLength}',
    );
  }
}
```

2. **Wrap isolate errors with proper exception types**:
```dart
Future<GenerateResponse> generate(...) async {
  try {
    final result = await Isolate.run<String>(() { ... });
    return GenerateResponse(...);
  } on EdgeVedaException {
    rethrow; // Already typed
  } catch (e) {
    throw GenerationException(
      'Generation failed',
      details: e.toString(),
      originalError: e,
    );
  }
}
```

3. **Add timeout protection** (optional but recommended):
```dart
Future<GenerateResponse> generate(..., {Duration? timeout}) async {
  final future = Isolate.run<String>(() { ... });
  if (timeout != null) {
    return future.timeout(timeout, onTimeout: () {
      throw GenerationException('Generation timed out after ${timeout.inSeconds}s');
    });
  }
  return future;
}
```

4. **Ensure NativeConfigScope and NativeParamsScope are imported**:
```dart
import 'ffi/native_memory.dart';
```
  </action>
  <verify>
Run: `cd flutter && dart analyze lib/src/edge_veda_impl.dart`
Expected: No errors. All exception types properly used.
  </verify>
  <done>
edge_veda_impl.dart has proper validation, error wrapping, and optional timeout support.
  </done>
</task>

</tasks>

<verification>
1. Run: `cd flutter && dart analyze` - zero errors
2. Verify Isolate.run usage: `grep -c "Isolate.run" flutter/lib/src/edge_veda_impl.dart` >= 2
3. Verify no Pointer storage: `grep -c "Pointer.*_context" flutter/lib/src/edge_veda_impl.dart` == 0
4. Verify no direct FFI calls outside isolate: Review code manually
</verification>

<success_criteria>
- All FFI calls wrapped in Isolate.run()
- No Pointer<> types stored as instance fields
- Config validation happens on main isolate (safe)
- Errors are wrapped with proper EdgeVedaException types
- Streaming removed/commented out (v2 scope)
</success_criteria>

<output>
After completion, create `.planning/phases/02-flutter-ffi-model-management/02-03-SUMMARY.md`
</output>
