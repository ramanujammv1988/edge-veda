---
phase: 02-flutter-ffi-model-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - flutter/lib/src/ffi/bindings.dart
  - flutter/lib/src/ffi/native_memory.dart
autonomous: true

must_haves:
  truths:
    - "FFI function signatures compile without errors"
    - "FFI structs match edge_veda.h C struct layouts exactly"
    - "Memory helpers provide RAII-style cleanup for native strings"
  artifacts:
    - path: "flutter/lib/src/ffi/bindings.dart"
      provides: "FFI function bindings matching edge_veda.h"
      exports: ["EdgeVedaNativeBindings", "ev_context_impl", "ev_config", "ev_generation_params", "ev_memory_stats"]
    - path: "flutter/lib/src/ffi/native_memory.dart"
      provides: "RAII memory management helpers"
      exports: ["NativeStringScope", "NativeConfigScope"]
  key_links:
    - from: "flutter/lib/src/ffi/bindings.dart"
      to: "core/include/edge_veda.h"
      via: "FFI lookupFunction calls"
      pattern: "lookupFunction.*ev_"
---

<objective>
Align Flutter FFI bindings to match edge_veda.h C API exactly, and establish RAII-style memory management patterns.

Purpose: FFI bindings must match C API signatures byte-for-byte for correct interop. Memory management patterns prevent leaks (Pitfall 6).
Output: Working FFI bindings and memory helpers that other plans depend on.
</objective>

<execution_context>
@/Users/ram/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ram/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-flutter-ffi-model-management/02-RESEARCH.md

# C API header - authoritative source for FFI signatures
@core/include/edge_veda.h

# Existing scaffolding to replace
@flutter/lib/src/ffi/bindings.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite FFI bindings to match edge_veda.h exactly</name>
  <files>flutter/lib/src/ffi/bindings.dart</files>
  <action>
Completely rewrite bindings.dart to match edge_veda.h signatures:

1. **FFI Struct Definitions** (must match C struct layouts exactly):
   - `ev_context_impl` - Opaque pointer (extends Opaque)
   - `ev_config` - Struct with fields: model_path (Pointer<Utf8>), backend (Int32), num_threads (Int32), context_size (Int32), batch_size (Int32), memory_limit_bytes (Size), auto_unload_on_memory_pressure (Bool), gpu_layers (Int32), use_mmap (Bool), use_mlock (Bool), seed (Int32), reserved (Pointer<Void>)
   - `ev_generation_params` - Struct with fields: max_tokens (Int32), temperature (Float), top_p (Float), top_k (Int32), repeat_penalty (Float), frequency_penalty (Float), presence_penalty (Float), stop_sequences (Pointer<Pointer<Utf8>>), num_stop_sequences (Int32), reserved (Pointer<Void>)
   - `ev_memory_stats` - Struct with fields: current_bytes (Size), peak_bytes (Size), limit_bytes (Size), model_bytes (Size), context_bytes (Size), reserved (Array<Size> of 8)

2. **Core Function Bindings** (match signatures exactly):
   - `ev_version()` -> Pointer<Utf8>
   - `ev_error_string(Int32 error)` -> Pointer<Utf8>
   - `ev_detect_backend()` -> Int32
   - `ev_is_backend_available(Int32 backend)` -> Bool
   - `ev_config_default(Pointer<ev_config>)` -> Void
   - `ev_init(Pointer<ev_config>, Pointer<Int32> error)` -> Pointer<ev_context_impl>
   - `ev_free(Pointer<ev_context_impl>)` -> Void
   - `ev_is_valid(Pointer<ev_context_impl>)` -> Bool
   - `ev_generation_params_default(Pointer<ev_generation_params>)` -> Void
   - `ev_generate(Pointer<ev_context_impl>, Pointer<Utf8> prompt, Pointer<ev_generation_params>, Pointer<Pointer<Utf8>> output)` -> Int32
   - `ev_free_string(Pointer<Utf8>)` -> Void
   - `ev_get_memory_usage(Pointer<ev_context_impl>, Pointer<ev_memory_stats>)` -> Int32
   - `ev_set_memory_limit(Pointer<ev_context_impl>, Size limit)` -> Int32
   - `ev_set_memory_pressure_callback(Pointer<ev_context_impl>, Pointer<NativeFunction<MemoryPressureCallback>>, Pointer<Void>)` -> Int32

3. **Error Code Enum**:
   - Define ev_error_t as Dart enum matching C enum values (EV_SUCCESS=0, EV_ERROR_INVALID_PARAM=-1, etc.)

4. **Backend Enum**:
   - Define ev_backend_t as Dart enum (EV_BACKEND_AUTO=0, EV_BACKEND_METAL=1, etc.)

5. **Library Loading**:
   - Keep existing platform-specific DynamicLibrary.open() logic
   - Use singleton pattern for instance

IMPORTANT: Use `@Packed(1)` if C structs are packed. Check edge_veda.h for any packing pragmas.
Do NOT include streaming functions (ev_generate_stream, etc.) - those are v2 scope.
  </action>
  <verify>
Run: `cd flutter && dart analyze lib/src/ffi/bindings.dart`
Expected: No errors. All FFI types resolve correctly.
  </verify>
  <done>
bindings.dart compiles without errors and exports all edge_veda.h functions needed for v1 (init, generate, memory, free).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RAII-style native memory helpers</name>
  <files>flutter/lib/src/ffi/native_memory.dart</files>
  <action>
Create native_memory.dart with memory management helpers that prevent leaks:

1. **NativeStringScope** - RAII wrapper for native strings:
```dart
/// Execute function with native string, automatically free after
extension NativeStringScope on String {
  R useNative<R>(R Function(Pointer<Utf8>) fn) {
    final ptr = toNativeUtf8();
    try {
      return fn(ptr);
    } finally {
      calloc.free(ptr);
    }
  }
}
```

2. **NativeConfigScope** - Allocate and populate ev_config struct:
```dart
class NativeConfigScope {
  final Pointer<ev_config> ptr;
  Pointer<Utf8>? _modelPathPtr;

  NativeConfigScope(EdgeVedaConfig config) : ptr = calloc<ev_config>() {
    _modelPathPtr = config.modelPath.toNativeUtf8();
    ptr.ref.model_path = _modelPathPtr!;
    ptr.ref.backend = config.useGpu ? 1 : 3; // METAL or CPU
    ptr.ref.num_threads = config.numThreads;
    ptr.ref.context_size = config.contextLength;
    // ... fill all fields
  }

  void free() {
    if (_modelPathPtr != null) calloc.free(_modelPathPtr!);
    calloc.free(ptr);
  }
}
```

3. **NativeParamsScope** - Allocate ev_generation_params struct with stop sequences

4. **Ownership Documentation**:
   - Comment block explaining: "Dart allocates with toNativeUtf8() -> Dart frees with calloc.free()"
   - Comment block explaining: "C++ allocates via ev_generate() -> C++ frees with ev_free_string()"

5. **Update imports** - Ensure bindings.dart imports from ffi package correctly

Remove the old NativePointerHelper class from bindings.dart (it had bugs like infinite recursion in toDartString).
  </action>
  <verify>
Run: `cd flutter && dart analyze lib/src/ffi/native_memory.dart`
Expected: No errors. All scope classes properly manage memory.
  </verify>
  <done>
native_memory.dart provides RAII-style wrappers that ensure cleanup in all code paths (success, exception, early return).
  </done>
</task>

</tasks>

<verification>
1. Run full package analysis: `cd flutter && dart analyze`
2. Verify FFI struct sizes match C (optional - hard to verify without runtime test)
3. Verify all ev_* functions from edge_veda.h v1 API are bound
</verification>

<success_criteria>
- bindings.dart compiles with zero analyzer errors
- All ev_* functions needed for Phase 2 requirements are bound
- Memory helpers provide try-finally cleanup pattern
- No infinite recursion bugs in string conversion helpers
</success_criteria>

<output>
After completion, create `.planning/phases/02-flutter-ffi-model-management/02-01-SUMMARY.md`
</output>
