---
phase: 02-flutter-ffi-model-management
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - flutter/lib/src/edge_veda_impl.dart
  - flutter/lib/edge_veda.dart
  - flutter/pubspec.yaml
autonomous: false

must_haves:
  truths:
    - "Memory pressure callbacks from C++ propagate to Flutter layer"
    - "Public API exports are clean and well-documented"
    - "Package analyzes with zero errors"
  artifacts:
    - path: "flutter/lib/src/edge_veda_impl.dart"
      provides: "Memory pressure callback via NativeCallable"
      contains: "NativeCallable.listener"
    - path: "flutter/lib/edge_veda.dart"
      provides: "Clean public API exports"
      exports: ["EdgeVeda", "EdgeVedaConfig", "GenerateOptions", "GenerateResponse", "ModelManager", "ModelInfo"]
  key_links:
    - from: "flutter/lib/src/edge_veda_impl.dart"
      to: "ev_set_memory_pressure_callback"
      via: "FFI callback registration"
      pattern: "evSetMemoryPressureCallback"
---

<objective>
Implement memory pressure callback propagation from C++ to Flutter, finalize public API exports, and verify Phase 2 integration.

Purpose: Memory pressure handling (R3.3) allows app to respond to iOS memory warnings. Clean exports ensure good DX.
Output: Complete, working Flutter SDK for Phase 2 requirements.
</objective>

<execution_context>
@/Users/ram/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ram/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-flutter-ffi-model-management/02-RESEARCH.md

# Prior plan outputs
@flutter/lib/src/ffi/bindings.dart
@flutter/lib/src/ffi/native_memory.dart
@flutter/lib/src/types.dart
@flutter/lib/src/edge_veda_impl.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement memory pressure callback with NativeCallable</name>
  <files>flutter/lib/src/edge_veda_impl.dart</files>
  <action>
Add memory pressure callback support using NativeCallable.listener:

1. **Add memory pressure stream to EdgeVeda class**:
```dart
class EdgeVeda {
  // ... existing fields ...

  final StreamController<MemoryPressureEvent> _memoryPressureController =
      StreamController<MemoryPressureEvent>.broadcast();

  /// Stream of memory pressure events from native layer
  Stream<MemoryPressureEvent> get onMemoryPressure => _memoryPressureController.stream;
}
```

2. **Create callback registration method** (MUST be called within Isolate.run context):

NOTE: NativeCallable.listener has a limitation - it creates a persistent callback that survives isolate termination. Since we're using per-request isolates, memory pressure callbacks are complex.

For v1, implement a SIMPLER approach - poll memory usage:
```dart
/// Get current memory statistics
Future<MemoryStats> getMemoryStats() async {
  _ensureInitialized();

  final modelPath = _config!.modelPath;
  // ... capture config ...

  return Isolate.run<MemoryStats>(() {
    final bindings = EdgeVedaNativeBindings.instance;
    // Init context, call ev_get_memory_usage, free context
    final stats = calloc<ev_memory_stats>();
    try {
      // ... init context ...
      bindings.evGetMemoryUsage(ctx, stats);
      return MemoryStats(
        currentBytes: stats.ref.current_bytes,
        peakBytes: stats.ref.peak_bytes,
        limitBytes: stats.ref.limit_bytes,
        modelBytes: stats.ref.model_bytes,
        contextBytes: stats.ref.context_bytes,
      );
    } finally {
      calloc.free(stats);
      // ... cleanup ...
    }
  });
}

/// Check if memory usage is above threshold
Future<bool> isMemoryPressure({double threshold = 0.8}) async {
  final stats = await getMemoryStats();
  if (stats.limitBytes == 0) return false;
  return stats.currentBytes / stats.limitBytes > threshold;
}
```

3. **Add MemoryStats type to types.dart** (if not already):
```dart
class MemoryStats {
  final int currentBytes;
  final int peakBytes;
  final int limitBytes;
  final int modelBytes;
  final int contextBytes;

  double get usagePercent => limitBytes > 0 ? currentBytes / limitBytes : 0;
  bool get isHighPressure => usagePercent > 0.8;

  const MemoryStats({...});
}
```

4. **Document the v1 limitation**:
```dart
/// Memory pressure handling for v1:
///
/// Due to the per-request Isolate.run() architecture, real-time memory
/// pressure callbacks from C++ are not supported in v1. Instead, use:
/// - [getMemoryStats()] to poll current memory usage
/// - [isMemoryPressure()] to check if usage exceeds threshold
///
/// For real-time callbacks, v2 will implement a long-lived worker isolate.
```

5. **Update dispose() to close stream**:
```dart
Future<void> dispose() async {
  _memoryPressureController.close();
  _isInitialized = false;
  _config = null;
}
```

NOTE: If real-time callbacks are required for v1, an alternative is to use a SEPARATE long-lived isolate just for memory monitoring. But this adds complexity - defer to v2 unless user feedback indicates it's critical.
  </action>
  <verify>
Run: `cd flutter && dart analyze lib/src/edge_veda_impl.dart`
Expected: No errors. getMemoryStats() method exists.
  </verify>
  <done>
EdgeVeda provides getMemoryStats() for polling memory usage. Real-time callbacks deferred to v2.
  </done>
</task>

<task type="auto">
  <name>Task 2: Finalize public API exports</name>
  <files>flutter/lib/edge_veda.dart, flutter/pubspec.yaml</files>
  <action>
Create clean public API export file:

1. **Create/update flutter/lib/edge_veda.dart**:
```dart
/// Edge Veda SDK - On-device LLM inference for Flutter
///
/// Example usage:
/// ```dart
/// import 'package:edge_veda/edge_veda.dart';
///
/// final edgeVeda = EdgeVeda();
/// await edgeVeda.init(EdgeVedaConfig(modelPath: '/path/to/model.gguf'));
/// final response = await edgeVeda.generate('Hello, world!');
/// print(response.text);
/// await edgeVeda.dispose();
/// ```
library edge_veda;

// Core SDK
export 'src/edge_veda_impl.dart' show EdgeVeda;

// Configuration and options
export 'src/types.dart' show
    EdgeVedaConfig,
    GenerateOptions,
    GenerateResponse,
    TokenChunk,
    DownloadProgress,
    ModelInfo,
    MemoryStats,
    MemoryPressureEvent;

// Exceptions (all typed, per R4.1)
export 'src/types.dart' show
    EdgeVedaException,
    InitializationException,
    ModelLoadException,
    GenerationException,
    DownloadException,
    ChecksumException,
    ModelValidationException,
    MemoryException,
    ConfigurationException;

// Model management
export 'src/model_manager.dart' show ModelManager, ModelRegistry;
```

2. **Verify pubspec.yaml has correct structure**:
```yaml
name: edge_veda
description: On-device LLM inference SDK for Flutter iOS apps
version: 1.0.0

environment:
  sdk: '>=3.0.0 <4.0.0'
  flutter: '>=3.10.0'

dependencies:
  flutter:
    sdk: flutter
  ffi: ^2.1.0
  path_provider: ^2.1.0
  http: ^1.1.0
  crypto: ^3.0.0
  path: ^1.8.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0
```

3. **Ensure no internal types are exported** - Only public API types should be in edge_veda.dart.
   - DO NOT export: EdgeVedaNativeBindings, NativeConfigScope, NativeParamsScope, ev_config, etc.
  </action>
  <verify>
Run: `cd flutter && dart analyze`
Expected: Zero errors across entire package.
Run: `cd flutter && dart pub get` (if needed)
  </verify>
  <done>
edge_veda.dart exports clean public API. All internal FFI types are hidden.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Flutter FFI layer with model management</what-built>
  <how-to-verify>
1. Navigate to flutter directory: `cd flutter`
2. Run full analysis: `dart analyze`
   - Expected: 0 errors, only warnings about unused code (ok for scaffold)

3. Verify key requirements are met:
   - R2.1 (Download): Check model_manager.dart has downloadModel()
   - R2.2 (Progress): Check DownloadProgress type exists with 0-100%
   - R2.3 (Caching): Check isModelDownloaded() method exists
   - R2.4 (Checksum): Check verifyModelChecksum() and ModelValidationException
   - R3.3 (Memory): Check getMemoryStats() method exists
   - R4.1 (Typed exceptions): Check all exception types exported in edge_veda.dart
   - Pitfall 3 (Isolate): grep for "Isolate.run" in edge_veda_impl.dart (should find 2+)

4. Review public API exports in edge_veda.dart:
   - Should export: EdgeVeda, EdgeVedaConfig, GenerateOptions, GenerateResponse, ModelManager, ModelInfo, all exceptions
   - Should NOT export: EdgeVedaNativeBindings, ev_config, NativeConfigScope, etc.
  </how-to-verify>
  <resume-signal>Type "approved" if analysis passes and requirements met, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Run: `cd flutter && dart analyze` - zero errors
2. Verify exports: `grep "^export" flutter/lib/edge_veda.dart` - should list all public types
3. Verify Isolate.run: `grep -c "Isolate.run" flutter/lib/src/edge_veda_impl.dart` >= 2
4. Verify memory stats: `grep "getMemoryStats" flutter/lib/src/edge_veda_impl.dart` - should find method
</verification>

<success_criteria>
- Package analyzes with zero errors
- Public API is clean (edge_veda.dart exports only public types)
- Memory stats polling works (getMemoryStats returns MemoryStats)
- Human verified all Phase 2 requirements are addressable
</success_criteria>

<output>
After completion, create `.planning/phases/02-flutter-ffi-model-management/02-04-SUMMARY.md`
</output>
