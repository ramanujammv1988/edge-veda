---
phase: 03-demo-app-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - flutter/example/lib/main.dart
autonomous: false

must_haves:
  truths:
    - "App cancels generation when user backgrounds the app (AppLifecycleState.paused)"
    - "dispose() is called on EdgeVeda instance when widget is destroyed"
    - "No memory leaks from lifecycle observer (removeObserver called)"
  artifacts:
    - path: "flutter/example/lib/main.dart"
      provides: "WidgetsBindingObserver implementation with lifecycle handling"
      min_lines: 500
      contains: "didChangeAppLifecycleState"
  key_links:
    - from: "_ChatScreenState"
      to: "WidgetsBinding.instance"
      via: "addObserver in initState, removeObserver in dispose"
      pattern: "WidgetsBinding\\.instance\\.(?:add|remove)Observer"
    - from: "didChangeAppLifecycleState"
      to: "generation cancellation"
      via: "cancel when AppLifecycleState.paused"
      pattern: "AppLifecycleState\\.paused"
---

<objective>
Implement proper iOS lifecycle handling to prevent App Store rejection and memory leaks.

Purpose: iOS requires apps to stop CPU-intensive tasks when backgrounded (Pitfall 5 - Critical). This plan implements WidgetsBindingObserver to detect backgrounding and cancel generation, plus proper dispose() cleanup to prevent memory leaks.

Output: Example app that gracefully handles backgrounding and hot reload without crashes or leaks.
</objective>

<execution_context>
@/Users/ram/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ram/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-flutter-ffi-model-management/02-04-SUMMARY.md
@.planning/phases/03-demo-app-polish/03-RESEARCH.md
@flutter/example/lib/main.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove unimplemented generateStream() API usage</name>
  <files>flutter/example/lib/main.dart</files>
  <action>
The example app currently calls `_edgeVeda.generateStream()` which is not implemented in Phase 2 (commented out as TODO(v2)). Replace streaming generation with synchronous generate() call.

Changes:
1. Replace `generateStream()` call (lines 169-194) with synchronous `generate()` call
2. Remove StreamSubscription field `_streamSubscription`
3. Use simple String response instead of stream buffer
4. Keep _isGenerating state for UI feedback
5. Remove streaming-specific UI updates (keep final result display)
6. Keep existing error handling pattern

**Why this approach:** Phase 2 only implements generate() (synchronous), not generateStream(). The research correctly identified streaming as v2 work. We must use what exists.

**Why not streaming:** The FFI layer uses Isolate.run() which creates a fresh context per call. Streaming requires a long-lived worker isolate pattern (documented in edge_veda_impl.dart lines 363-375).
  </action>
  <verify>
1. dart analyze flutter/example shows 0 errors in main.dart
2. Grep confirms no "generateStream" calls: `grep -n "generateStream" flutter/example/lib/main.dart` returns empty
3. Grep confirms generate() is used: `grep -n "\.generate(" flutter/example/lib/main.dart` shows usage
  </verify>
  <done>
Example app uses only implemented APIs (generate, not generateStream). Code compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace unimplemented getMemoryUsageMb() with getMemoryStats()</name>
  <files>flutter/example/lib/main.dart</files>
  <action>
The example app calls `_edgeVeda.getMemoryUsageMb()` which doesn't exist. Phase 2 implements `getMemoryStats()` which returns a MemoryStats object.

Changes:
1. Replace all `getMemoryUsageMb()` calls with `getMemoryStats()`
2. Extract memory MB from stats: `(await _edgeVeda.getMemoryStats()).currentBytes / (1024 * 1024)`
3. Update info dialog (line 287) to use getMemoryStats()
4. Update post-generation memory logging (line 201) to use getMemoryStats()
5. Store memory value in state for display

**Why this works:** Phase 2 implements getMemoryStats() (edge_veda_impl.dart line 413) which returns MemoryStats with currentBytes, usagePercent, isHighPressure fields.
  </action>
  <verify>
1. Grep confirms no getMemoryUsageMb calls: `grep -n "getMemoryUsageMb" flutter/example/lib/main.dart` returns empty
2. Grep confirms getMemoryStats usage: `grep -n "getMemoryStats" flutter/example/lib/main.dart` shows usage
3. dart analyze shows 0 errors
  </verify>
  <done>
Example app uses correct memory API. Memory display shows actual MB values from MemoryStats.currentBytes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement WidgetsBindingObserver for lifecycle handling</name>
  <files>flutter/example/lib/main.dart</files>
  <action>
Add lifecycle observer to detect app backgrounding and cancel generation. This is MANDATORY for App Store approval (Pitfall 5 - Critical: iOS kills apps running CPU-intensive tasks in background).

Implementation pattern from research (03-RESEARCH.md lines 56-91):

1. Add `with WidgetsBindingObserver` to `_ChatScreenState` class declaration
2. In `initState()`, add: `WidgetsBinding.instance.addObserver(this);`
3. In `dispose()`, add: `WidgetsBinding.instance.removeObserver(this);` BEFORE _edgeVeda.dispose()
4. Override `didChangeAppLifecycleState(AppLifecycleState state)`:
   - If `state == AppLifecycleState.paused` and `_isGenerating == true`:
     - Set `_isGenerating = false`
     - Show SnackBar: "Generation cancelled - app backgrounded"
   - If `state == AppLifecycleState.resumed`:
     - No action needed (user can start new generation)
5. Update _sendMessage() to set `_isGenerating = true` before generation
6. Update _sendMessage() to set `_isGenerating = false` in finally block

**Critical: Order matters in dispose():**
```dart
@override
void dispose() {
  WidgetsBinding.instance.removeObserver(this); // FIRST - prevent callbacks
  _edgeVeda.dispose(); // SECOND
  _modelManager.dispose();
  _promptController.dispose();
  _scrollController.dispose();
  super.dispose(); // LAST
}
```

**Why this prevents App Store rejection:** iOS background execution policy requires apps to stop heavy computation when user leaves app. Not implementing this causes jetsam kills and rejection.

**Why this prevents memory leaks:** If we don't removeObserver(), the observer stays registered after widget disposal, causing "setState() called after dispose()" crashes.
  </action>
  <verify>
1. Grep confirms WidgetsBindingObserver mixin: `grep -n "with WidgetsBindingObserver" flutter/example/lib/main.dart`
2. Grep confirms addObserver in initState: `grep -n "addObserver" flutter/example/lib/main.dart`
3. Grep confirms removeObserver in dispose: `grep -n "removeObserver" flutter/example/lib/main.dart`
4. Grep confirms lifecycle handler: `grep -n "didChangeAppLifecycleState" flutter/example/lib/main.dart`
5. Grep confirms paused state handling: `grep -n "AppLifecycleState.paused" flutter/example/lib/main.dart`
6. dart analyze shows 0 errors
  </verify>
  <done>
App implements WidgetsBindingObserver. Backgrounding triggers cancellation. dispose() properly cleans up observer. No memory leaks from lifecycle handling.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Verify end-to-end chat functionality</name>
  <files></files>
  <what-built>
Fixed example app with corrected API usage and lifecycle handling.
  </what-built>
  <how-to-verify>
1. Run app on real device: `cd flutter/example && flutter run --release -d <device>`
2. Wait for model download (first run only, ~2-5 minutes on WiFi)
3. Tap "Initialize" button and wait for "Ready to chat!" status
4. Type prompt: "What is 2+2?"
5. Tap send button
6. Verify response appears in chat (e.g., contains "4" or "four")
7. Verify metrics bar shows non-"-" values (tok/s, memory)
8. Test backgrounding: Start generation, press home button, return to app
9. Verify cancellation message appears and app doesn't crash
  </how-to-verify>
  <resume-signal>Type "verified" when chat works end-to-end, or describe the error you encountered</resume-signal>
</task>

</tasks>

<verification>
Run from project root:
```bash
cd flutter/example
dart analyze lib/main.dart
# Expect: 0 errors

# Verify lifecycle handling exists
grep -n "with WidgetsBindingObserver" lib/main.dart
grep -n "didChangeAppLifecycleState" lib/main.dart
grep -n "AppLifecycleState.paused" lib/main.dart

# Verify only implemented APIs used
grep -n "generateStream" lib/main.dart  # Expect: empty
grep -n "getMemoryUsageMb" lib/main.dart  # Expect: empty
grep -n "\.generate(" lib/main.dart  # Expect: usage found
grep -n "getMemoryStats" lib/main.dart  # Expect: usage found
```
</verification>

<success_criteria>
1. Example app compiles with 0 dart analyze errors
2. App uses only implemented SDK APIs (generate, getMemoryStats)
3. WidgetsBindingObserver properly registered and unregistered
4. Generation cancels when app backgrounds (paused state)
5. No memory leaks from lifecycle observer (removeObserver called in dispose)
</success_criteria>

<output>
After completion, create `.planning/phases/03-demo-app-polish/03-01-SUMMARY.md`
</output>
